<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"fixtures.js.html":{"id":"fixtures.js.html","title":"Source: fixtures.js","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Source: fixtures.js &quot;use strict&quot;; /** * `Video` fixtures. * * @module */ var CONF = require(&quot;./config&quot;); /** * Fixture to capture tests video. * * @global * @function * @arg {function} func - Test funciton. */ global.fxVideo = func =&gt; { var isStarted; var errNumBefore; before(async () =&gt; { errNumBefore = CONF.curTestCase.errors.length; isStarted = await SS.startVideo(); }); func(); after(async () =&gt; { if (!isStarted) return; await SS.stopVideo(); isStarted = false; if (!CONF.video.save &amp;&amp; CONF.curTestCase.errors.length === errNumBefore) { SS.removeVideo(); }; }); }; × Search results Close "},"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Source: config.js &quot;use strict&quot;; /** * Configures `Video` plugin. Extends `GlaceJS` configuration. * * @namespace GlaceConfig * @prop {object} video - `Video` options. * @prop {boolean} [video.capture=false] - Flag to capture video. * @prop {boolean} [video.save=false] - Flag to save video for passed tests too. */ var U = require(&quot;glace-utils&quot;); var config = U.config; var args = config.args; if (process.platform === &quot;win32&quot;) { require(&quot;binary&quot;).activateFFmpeg(); }; config.video = U.defVal(config.video, {}); config.video.capture = U.defVal(args.video, false); config.video.save = U.defVal(args.videoSave, false); module.exports = config; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Source: index.js &quot;use strict&quot;; /** * `GlaceJS Video` plugin. * * @module */ var config, pluginHelp, Steps; Object.defineProperties(exports, { /** * @type {GlaceConfig} */ config: { get: function () { config = config || require(&quot;./config&quot;); return config; }, }, /** * @type {pluginHelp} */ pluginHelp: { get: function () { pluginHelp = pluginHelp || require(&quot;./pluginHelp&quot;); return pluginHelp; } }, /** * @type {VideoSteps} */ Steps: { get: function () { Steps = Steps || require(&quot;./steps&quot;); return Steps; }, }, }); × Search results Close "},"pluginHelp.js.html":{"id":"pluginHelp.js.html","title":"Source: pluginHelp.js","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Source: pluginHelp.js &quot;use strict&quot;; /** * `Video` plugin help. * * @function * @name pluginHelp * @arg {yargs} yargs - `yargs` instance in order to expand its options. * @arg {function} d - Function to manage option description: join, colorize, etc. * @return {yargs} - Expanded `yargs` instance. */ module.exports = (args, d) =&gt; { return args .options({ &quot;video&quot;: { describe: d(&quot;Capture video of executed tests.&quot;, &quot;Video will be removed if test is passed.&quot;), type: &quot;boolean&quot;, group: &quot;Video:&quot;, }, &quot;video-save&quot;: { describe: d(&quot;Save video for passed tests too if video is&quot;, &quot;captured.&quot;), type: &quot;boolean&quot;, group: &quot;Video:&quot;, }, }); }; × Search results Close "},"video.js.html":{"id":"video.js.html","title":"Source: video.js","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Source: video.js &quot;use strict&quot;; /** * Creates a new instance of VideoRecorder. * * @class * @name VideoRecorder * @classdesc contains methods to record video for tests * @property {boolean} [isRunning=false] - flag is video recorder running or no * @property {?string} [filePath=null] - path video file */ var path = require(&quot;path&quot;); var spawn = require(&quot;cross-spawn&quot;); var which = require(&quot;which&quot;); var U = require(&quot;glace-utils&quot;); var LOG = U.logger; var VideoRecorder = function () { this.isRunning = false; this.filePath = null; this._process = null; this._recordOpts = null; }; /** * Configures video recorder. * * @method * @arg {object} [opts] - recorder configuration * @arg {number} [opts.fps=30] - video framerate * @arg {number} [opts.width=1024] - video width * @arg {number} [opts.height=768] - video height * @arg {number} [opts.x=0] - `X`-offset on display * @arg {number} [opts.y=0] - `Y`-offset on display */ VideoRecorder.prototype.configure = function (opts) { opts = U.defVal(opts, {}); opts.fps = U.defVal(opts.fps, 30); opts.width = U.defVal(opts.width, 1024); opts.height = U.defVal(opts.height, 768); opts.x = U.defVal(opts.x, 0); opts.y = U.defVal(opts.y, 0); opts.size = opts.width + &quot;x&quot; + opts.height; this.filePath = U.defVal(opts.path, path.resolve(__dirname, &quot;out.avi&quot;)); if (process.platform === &quot;win32&quot;) { which.sync(&quot;ffmpeg&quot;); this._recordCmd = &quot;ffmpeg&quot;; this._recordOpts = [ &quot;-y&quot;, &quot;-loglevel&quot;, &quot;quiet&quot;, &quot;-video_size&quot;, opts.size, &quot;-offset_x&quot;, opts.x, &quot;-offset_y&quot;, opts.y, &quot;-draw_mouse&quot;, 0, &quot;-framerate&quot;, opts.fps, &quot;-f&quot;, &quot;gdigrab&quot;, &quot;-i&quot;, &quot;desktop&quot;, &quot;-vcodec&quot;, &quot;libx264&quot;, this.filePath ]; } else if (process.platform === &quot;linux&quot;) { if (which.sync(&quot;avconv&quot;, { nothrow: true })) { this._recordCmd = &quot;avconv&quot;; } else if (which.sync(&quot;ffmpeg&quot;, { nothrow: true })) { this._recordCmd = &quot;ffmpeg&quot;; } else { throw new Error(&quot;not found: avconv or ffmpeg&quot;); }; this._recordOpts = [ &quot;-y&quot;, &quot;-loglevel&quot;, &quot;quiet&quot;, &quot;-f&quot;, &quot;x11grab&quot;, &quot;-r&quot;, opts.fps, &quot;-s&quot;, opts.size, &quot;-i&quot;, `${process.env.DISPLAY}+${opts.x},${opts.y}`, &quot;-codec&quot;, &quot;libx264&quot;, this.filePath ]; } else { throw new Error(`Video capture isn't supported ` + `on platform '${process.platform}'`); }; }; /** * Starts video recorder. * * @method * @throws {Error} if video recorder is started already * @throws {Error} if video recorder isn't configured yet */ VideoRecorder.prototype.start = function () { if (this.isRunning) return; if (!this._recordOpts) throw new Error(&quot;Video recorder isn't configured yet&quot;); this._process = spawn(this._recordCmd, this._recordOpts, { killSignal: &quot;SIGINT&quot; }); this.isRunning = true; }; /** * Stops video recorder. * * @method * @throws {Error} if video recorder isn't started yet */ VideoRecorder.prototype.stop = function () { if (!this.isRunning) return; return new Promise((resolve, reject) =&gt; { this._process.on(&quot;exit&quot;, (code, signal) =&gt; { LOG.debug(`${this._recordCmd} was stopped with ` + `code ${code} and signal ${signal}`); this.isRunning = false; resolve(); }); this._process.on(&quot;error&quot;, reject); var result = this._process.kill(&quot;SIGINT&quot;); if (!result) reject(`Oops! Can't kill ${this._recordCmd}`); }); }; module.exports = VideoRecorder; × Search results Close "},"steps.js.html":{"id":"steps.js.html","title":"Source: steps.js","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Source: steps.js &quot;use strict&quot;; /** * Steps for video recording. * * @mixin VideoSteps * @prop {VideoRecorder} video - Video recorder instance. */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var _ = require(&quot;lodash&quot;); var resolution = require(&quot;screen-resolution&quot;); var uuid = require(&quot;uuid/v4&quot;); var U = require(&quot;glace-utils&quot;); var LOG = U.logger; require(&quot;./fixtures&quot;); var VideoRecorder = require(&quot;./video&quot;); var VideoSteps = { /** * Step to start video recording. Step recall will be skipped if video * recording wasn't stopped before. * * @async * @method * @instance * @arg {object} [opts] - Step options. * @arg {string} [opts.name] - File name. Extension `.avi` will be * added automatically. Default name will be generated with `uuid` * algorithm. * @arg {string} [opts.path] - Folder to save video. * @arg {boolean} [opts.check=true] - Flag to check that video recording * was launched. * @return {Promise&lt;boolean&gt;} `true` if step was executed, `false` if * was skipped. * @throws {AssertionError} If video recording wasn't launched. */ startVideo: async function (opts) { if (this._isVideoStarted) { LOG.warn(&quot;Step to start video recording was passed already&quot;); return false; }; opts = U.defVal(opts, {}); var fileName = U.defVal(opts.name, uuid()) + &quot;.avi&quot;; var check = U.defVal(opts.check, true); this.video = this.video || new VideoRecorder(); var videoOpts = {}; var screen = await resolution.get(); if (this.webdriver &amp;&amp; await this.webdriver.session()) { _.assign(videoOpts, (await this.webdriver.windowHandlePosition()).value); _.assign(videoOpts, (await this.webdriver.windowHandleSize()).value); if (videoOpts.x &lt; 0) videoOpts.x = 0; if (videoOpts.y &lt; 0) videoOpts.y = 0; if (videoOpts.x + videoOpts.width &gt; screen.width) { videoOpts.width = screen.width - videoOpts.x; }; if (videoOpts.y + videoOpts.height &gt; screen.height) { videoOpts.height = screen.height - videoOpts.y; }; } else { videoOpts = { x: 0, y: 0, width: screen.width, height: screen.height }; }; var testName = CONF.curTestCase ? _.kebabCase(CONF.curTestCase.name) : &quot;&quot;; videoOpts.path = U.mkpath( U.defVal(opts.path, path.resolve(CONF.reportsDir, testName, &quot;videos&quot;)), fileName); this.video.configure(videoOpts); this.video.start(); await this.pause(1, &quot;it needs a time to start recording&quot;); if (check) { expect(this.video.isRunning, &quot;Video recording wasn't launched&quot;) .to.be.true; }; this._isVideoStarted = true; return true; }, /** * Step to stop video recording. Step call will be skipped if video * recording wasn't launched before. * * @async * @method * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that video recording * was stopped. * @return {Promise&lt;string&gt;} Path to recorded video. * @return {Promise&lt;boolean&gt;} `false` if step was skipped. * @throws {AssertionError} If video recording wasn't stopped. */ stopVideo: async function (opts) { if (!this._isVideoStarted) { LOG.warn(&quot;Step to start video recording wasn't passed yet&quot;); return false; }; opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); await this.pause(1, &quot;it needs a time to gather latest frames&quot;); await this.video.stop(); if (check) { expect(this.video.isRunning, &quot;Video recording was still running&quot;) .to.be.false; }; this._isVideoStarted = false; return this.video.filePath; }, /** * Step to get path to recorded video. * * @method * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that video is recorded * and path exists. * @return {string} Path to recorded video. */ getVideo: function (opts) { expect(this.video, &quot;Video recorder isn't initialized&quot;).to.exist; opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); if (check) { expect(this.video.isRunning, &quot;Can't get recorded video file path, &quot; + &quot;because video is still recording&quot;).to.be.false; expect(this.video.filePath, &quot;Can't get recorded video file path, &quot; + &quot;because it's empty&quot;).to.not.be.empty; }; return this.video.filePath; }, /** * Step to remove recorded video. * * @method * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check step result. * @return {boolean} `true` if step was executed, `false` if was skipped. * @throws {AssertionError} If video file wasn't removed. */ removeVideo: function (opts) { if (!this.video.filePath || !fs.existsSync(this.video.filePath)) { LOG.warn(&quot;Video file doesn't exist&quot;); return false; }; opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); fs.unlinkSync(this.video.filePath); if (check) { expect(fs.existsSync(this.video.filePath), `Video file '${this.video.filePath}' wasn't removed`) .to.be.false; }; return true; }, }; module.exports = VideoSteps; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Global Methods fxVideo(func) Fixture to capture tests video. Parameters: Name Type Description func function Test funciton. Source: fixtures.js, line 16 pluginHelp(yargs, d) Video plugin help. Parameters: Name Type Description yargs yargs yargs instance in order to expand its options. d function Function to manage option description: join, colorize, etc. Source: pluginHelp.js, line 2 Returns: Expanded yargs instance. Type yargs × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Modules Classes VideoRecorder Mixins VideoSteps Namespaces GlaceConfig × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Classes Classes VideoRecorder Mixins VideoSteps Namespaces GlaceConfig × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Namespaces Classes VideoRecorder Mixins VideoSteps Namespaces GlaceConfig × Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Mixins Classes VideoRecorder Mixins VideoSteps Namespaces GlaceConfig × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp GlaceJS Video pluginProvides steps for GlaceJS framework to capture video of executed tests. How to installnpm i glace-videoHow to usevar glaceVideo = require(&quot;glace-video&quot;); glaceVideo.Steps; glaceVideo.config;If plugin is used as a part of GlaceJS it will be loaded automatically. CLI options --video - Use video capture for launched autotests. --video-save - Save video for all tests (by default for failed only). API config fixtures steps × Search results Close "},"GlaceConfig.html":{"id":"GlaceConfig.html","title":"Namespace: GlaceConfig","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Namespace: GlaceConfig GlaceConfig Configures Video plugin. Extends GlaceJS configuration. Properties: Name Type Description video object Video options. Properties Name Type Argument Default Description capture boolean &lt;optional&gt; false Flag to capture video. save boolean &lt;optional&gt; false Flag to save video for passed tests too. Source: config.js, line 2 × Search results Close "},"module-fixtures.html":{"id":"module-fixtures.html","title":"Module: fixtures","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Module: fixtures Video fixtures. Source: fixtures.js, line 2 × Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Module: index GlaceJS Video plugin. Source: index.js, line 2 Members &lt;inner&gt; config :GlaceConfig Type: GlaceConfig Source: index.js, line 14 &lt;inner&gt; pluginHelp :pluginHelp Type: pluginHelp Source: index.js, line 23 &lt;inner&gt; Steps :VideoSteps Type: VideoSteps Source: index.js, line 32 × Search results Close "},"VideoRecorder.html":{"id":"VideoRecorder.html","title":"Class: VideoRecorder","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Class: VideoRecorder VideoRecorder contains methods to record video for tests new VideoRecorder() Creates a new instance of VideoRecorder. Properties: Name Type Argument Default Description isRunning boolean &lt;optional&gt; false flag is video recorder running or no filePath string &lt;optional&gt; &lt;nullable&gt; null path video file Source: video.js, line 2 Methods configure( [opts]) Configures video recorder. Parameters: Name Type Argument Description opts object &lt;optional&gt; recorder configuration Properties Name Type Argument Default Description fps number &lt;optional&gt; 30 video framerate width number &lt;optional&gt; 1024 video width height number &lt;optional&gt; 768 video height x number &lt;optional&gt; 0 X-offset on display y number &lt;optional&gt; 0 Y-offset on display Source: video.js, line 37 start() Starts video recorder. Source: video.js, line 92 Throws: if video recorder is started already Type Error if video recorder isn't configured yet Type Error stop() Stops video recorder. Source: video.js, line 107 Throws: if video recorder isn't started yet Type Error × Search results Close "},"VideoSteps.html":{"id":"VideoSteps.html","title":"Mixin: VideoSteps","body":" GlaseJS Namespaces GlaceConfig Modules fixturesindex Classes VideoRecorder Mixins VideoSteps Global fxVideopluginHelp Mixin: VideoSteps VideoSteps Steps for video recording. Properties: Name Type Description video VideoRecorder Video recorder instance. Source: steps.js, line 2 Methods getVideo( [opts]) Step to get path to recorded video. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that video is recorded and path exists. Source: steps.js, line 145 Returns: Path to recorded video. Type string removeVideo( [opts]) Step to remove recorded video. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check step result. Source: steps.js, line 173 Throws: If video file wasn't removed. Type AssertionError Returns: true if step was executed, false if was skipped. Type boolean &lt;async&gt; startVideo( [opts]) Step to start video recording. Step recall will be skipped if video recording wasn't stopped before. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description name string &lt;optional&gt; File name. Extension .avi will be added automatically. Default name will be generated with uuid algorithm. path string &lt;optional&gt; Folder to save video. check boolean &lt;optional&gt; true Flag to check that video recording was launched. Source: steps.js, line 40 Throws: If video recording wasn't launched. Type AssertionError Returns: true if step was executed, false if was skipped. Type Promise.&lt;boolean&gt; &lt;async&gt; stopVideo( [opts]) Step to stop video recording. Step call will be skipped if video recording wasn't launched before. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that video recording was stopped. Source: steps.js, line 112 Throws: If video recording wasn't stopped. Type AssertionError Returns: Path to recorded video. Type Promise.&lt;string&gt; false if step was skipped. Type Promise.&lt;boolean&gt; × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
